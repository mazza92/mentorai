const puppeteer = require('puppeteer');

/**
 * Scalable Caption Fetcher using Puppeteer
 *
 * Why this is better than cookies/yt-dlp:
 * - Uses REAL browser (Chrome headless)
 * - No cookies to maintain/expire
 * - Bypasses bot detection (actual browser session)
 * - Works on Railway with puppeteer-core
 * - Can handle CAPTCHA if needed
 * - Truly scalable (spin up multiple instances)
 */
class PuppeteerCaptionFetcher {
  constructor() {
    this.browser = null;
    this.browserPromise = null;
  }

  /**
   * Initialize browser instance (reuse across requests)
   */
  async getBrowser() {
    if (this.browser && this.browser.isConnected()) {
      return this.browser;
    }

    // If already initializing, wait for it
    if (this.browserPromise) {
      return this.browserPromise;
    }

    this.browserPromise = (async () => {
      console.log('[PuppeteerCaptionFetcher] Launching browser...');

      const isProduction = process.env.NODE_ENV === 'production';

      const launchOptions = {
        headless: true,
        args: [
          '--no-sandbox',
          '--disable-setuid-sandbox',
          '--disable-dev-shm-usage',
          '--disable-accelerated-2d-canvas',
          '--disable-gpu',
          '--window-size=1920x1080',
          '--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
        ]
      };

      // On Railway/production, use chromium
      if (isProduction) {
        launchOptions.executablePath = '/usr/bin/chromium-browser';
      }

      this.browser = await puppeteer.launch(launchOptions);
      console.log('[PuppeteerCaptionFetcher] âœ“ Browser launched');

      return this.browser;
    })();

    const browser = await this.browserPromise;
    this.browserPromise = null;
    return browser;
  }

  /**
   * Fetch captions for a single video using Puppeteer
   * @param {string} videoId - YouTube video ID
   * @returns {Promise<Object>} Caption data
   */
  async fetchCaptions(videoId) {
    const startTime = Date.now();
    console.log(`[PuppeteerCaptionFetcher] Fetching captions for: ${videoId}`);

    let page = null;

    try {
      const browser = await this.getBrowser();
      page = await browser.newPage();

      // Set realistic viewport and user agent
      await page.setViewport({ width: 1920, height: 1080 });
      await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36');

      // Set extra headers to look more like real browser
      await page.setExtraHTTPHeaders({
        'Accept-Language': 'en-US,en;q=0.9',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
      });

      // Navigate to video page
      const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;
      await page.goto(videoUrl, {
        waitUntil: 'networkidle0',
        timeout: 30000
      });

      // Wait for page to load (newer Puppeteer API)
      await new Promise(resolve => setTimeout(resolve, 2000));

      // Extract ytInitialPlayerResponse from page
      const captionData = await page.evaluate(() => {
        try {
          // Get ytInitialPlayerResponse from page
          const scriptContent = document.documentElement.innerHTML;
          const match = scriptContent.match(/ytInitialPlayerResponse\s*=\s*({.+?});/);

          if (!match) {
            return { error: 'Could not find ytInitialPlayerResponse' };
          }

          const playerResponse = JSON.parse(match[1]);

          // Extract captions
          const captionTracks = playerResponse?.captions?.playerCaptionsTracklistRenderer?.captionTracks;

          if (!captionTracks || captionTracks.length === 0) {
            return { error: 'No captions available' };
          }

          // Get the first caption track URL
          const captionTrack = captionTracks[0];
          return {
            success: true,
            captionUrl: captionTrack.baseUrl,
            language: captionTrack.languageCode,
            isAutoGenerated: captionTrack.kind === 'asr'
          };

        } catch (error) {
          return { error: error.message };
        }
      });

      if (captionData.error) {
        console.log(`[PuppeteerCaptionFetcher] âœ— ${captionData.error}`);
        return {
          success: false,
          error: captionData.error
        };
      }

      // Fetch caption content - YouTube now returns JSON3 format
      const captionUrl = captionData.captionUrl + '&fmt=json3';
      const captionResponse = await page.goto(captionUrl, {
        waitUntil: 'networkidle0',
        timeout: 15000
      });

      const captionContent = await captionResponse.text();

      // Debug
      console.log(`[PuppeteerCaptionFetcher] Caption format preview: ${captionContent.substring(0, 200)}...`);

      // Parse JSON3 format
      let segments = [];
      try {
        const json3Data = JSON.parse(captionContent);

        if (json3Data.events) {
          for (const event of json3Data.events) {
            if (event.segs) {
              const text = event.segs.map(seg => seg.utf8).join('');
              if (text.trim()) {
                segments.push({
                  text: text.trim(),
                  offset: event.tStartMs || 0,
                  duration: event.dDurationMs || 0
                });
              }
            }
          }
        }

        console.log(`[PuppeteerCaptionFetcher] Parsed ${segments.length} segments from JSON3`);

      } catch (jsonError) {
        console.log(`[PuppeteerCaptionFetcher] JSON parsing failed, trying XML...`);

        // Fallback to XML parsing
        const captionMatches = [...captionContent.matchAll(/<text start="([^"]+)" dur="([^"]+)"[^>]*>([^<]+)<\/text>/g)];

        segments = captionMatches.map(match => ({
          text: this.decodeHtml(match[3]),
          offset: parseFloat(match[1]) * 1000,
          duration: parseFloat(match[2]) * 1000
        }));

        console.log(`[PuppeteerCaptionFetcher] Parsed ${segments.length} segments from XML`);
      }

      const fullText = segments.map(s => s.text).join(' ');

      const elapsed = Date.now() - startTime;
      console.log(`[PuppeteerCaptionFetcher] âœ“ Success: ${segments.length} segments (${fullText.length} chars) in ${elapsed}ms`);

      return {
        success: true,
        segments,
        text: fullText,
        language: captionData.language,
        isAutoGenerated: captionData.isAutoGenerated,
        charCount: fullText.length,
        segmentCount: segments.length
      };

    } catch (error) {
      const elapsed = Date.now() - startTime;
      console.error(`[PuppeteerCaptionFetcher] âœ— Error after ${elapsed}ms:`, error.message);

      return {
        success: false,
        error: error.message
      };

    } finally {
      if (page) {
        await page.close().catch(() => {});
      }
    }
  }

  /**
   * Fetch captions for multiple videos with concurrency control
   * @param {Array<string>} videoIds - Array of video IDs
   * @param {number} concurrency - Max concurrent browser pages
   * @returns {Promise<Array>} Results array
   */
  async fetchMultiple(videoIds, concurrency = 5) {
    console.log(`[PuppeteerCaptionFetcher] ðŸ“¦ Batch fetching ${videoIds.length} captions (concurrency: ${concurrency})`);

    const results = [];
    const chunks = this.chunkArray(videoIds, concurrency);

    for (let i = 0; i < chunks.length; i++) {
      const chunk = chunks[i];
      console.log(`[PuppeteerCaptionFetcher] Processing batch ${i + 1}/${chunks.length} (${chunk.length} videos)`);

      const promises = chunk.map(videoId =>
        this.fetchCaptions(videoId)
          .catch(error => ({
            success: false,
            videoId,
            error: error.message
          }))
      );

      const chunkResults = await Promise.all(promises);
      results.push(...chunkResults);

      // Small delay between batches
      if (i < chunks.length - 1) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    const successful = results.filter(r => r.success).length;
    const successRate = ((successful / videoIds.length) * 100).toFixed(1);

    console.log(`[PuppeteerCaptionFetcher] âœ… Complete: ${successful}/${videoIds.length} successful (${successRate}%)`);

    return results;
  }

  /**
   * Decode HTML entities in caption text
   */
  decodeHtml(html) {
    return html
      .replace(/&amp;/g, '&')
      .replace(/&lt;/g, '<')
      .replace(/&gt;/g, '>')
      .replace(/&quot;/g, '"')
      .replace(/&#39;/g, "'")
      .replace(/&nbsp;/g, ' ')
      .replace(/<[^>]*>/g, '');
  }

  /**
   * Chunk array helper
   */
  chunkArray(array, size) {
    const chunks = [];
    for (let i = 0; i < array.length; i += size) {
      chunks.push(array.slice(i, i + size));
    }
    return chunks;
  }

  /**
   * Close browser instance (cleanup)
   */
  async close() {
    if (this.browser && this.browser.isConnected()) {
      console.log('[PuppeteerCaptionFetcher] Closing browser...');
      await this.browser.close();
      this.browser = null;
    }
  }
}

module.exports = new PuppeteerCaptionFetcher();
